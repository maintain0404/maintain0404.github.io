<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법 | Taein.dev</title>
<meta name=keywords content><meta name=description content="소트트웨어에서 여러 작업 흐름을 관리하는 방법"><meta name=author content="Me"><link rel=canonical href=https://maintain0404.github.io/posts/resource_managing_in_software.ko/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://maintain0404.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://maintain0404.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://maintain0404.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://maintain0404.github.io/apple-touch-icon.png><link rel=mask-icon href=https://maintain0404.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-HBTP6KYQ2X"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-HBTP6KYQ2X",{anonymize_ip:!1})}</script><meta property="og:title" content="소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법"><meta property="og:description" content="소트트웨어에서 여러 작업 흐름을 관리하는 방법"><meta property="og:type" content="article"><meta property="og:url" content="https://maintain0404.github.io/posts/resource_managing_in_software.ko/"><meta property="og:image" content="https://maintain0404.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-10T23:43:57+09:00"><meta property="article:modified_time" content="2023-12-10T23:43:57+09:00"><meta property="og:site_name" content="Taein.dev"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://maintain0404.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법"><meta name=twitter:description content="소트트웨어에서 여러 작업 흐름을 관리하는 방법"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://maintain0404.github.io/posts/"},{"@type":"ListItem","position":2,"name":"소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법","item":"https://maintain0404.github.io/posts/resource_managing_in_software.ko/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법","name":"소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법","description":"소트트웨어에서 여러 작업 흐름을 관리하는 방법","keywords":[],"articleBody":"글 들어가며 프로그래밍에서 작업 흐름이 여럿인 경우를 제법 만날 수 있습니다. 목적부터 작업 흐름이 여럿일 수 있고(여러 사용자가 있는 구조), 더 빠른 처리를 위해 여럿을 사용할 수도 있고(병렬 프로그래밍), 관리를 위해 개념적으로 쪼개어 작업할 수 도 있습니다.\n하지만 여러 작업 흐름을 고려하고 프로그래밍을 하면 작업 흐름끼리 충돌해서 프로그램이 죽어버리거나, 데이터가 오염되는 문제가 생길 수가 있습니다. 데이터베이스에서 간헐적으로 발생하는 데드락이나, 구글 독스 등 클라우드 프로그램을 이용할 때 글자가 갑자기 사라지는 것이 그 예시입니다.\n이 글에서는 소프트웨어에서 여러 작업 흐름을 어떻게 제어하는지 개념적으로 간단히 알아보겠습니다.\n하나로 전부 처리하기 튜닝의 끝은 수정이라는 말처럼 프로그래밍 관점에서 놀랍고 높은 수준이고 멋있는 기술을 사용하는 것은 아니지만 제일 좋은 방법입니다. 일단 생각할 게 없기 때문에 구현이 아주 쉽습니다. 그리고 누가 작업할지 따질 필요도 없기 때문에 아주 효율적입니다.\n규칙을 두고 나누기 작업자 전부의 Ground Rule을 정하고 나누는 방법입니다. 규칙만 잘 정한다면 신경써야할 부분이 적고, 성능 손실도 적게 병렬 처리가 가능합니다.\n네트워크 초창기 전송 프로토콜인 ALOHA에서는 충돌이 일어나지 않도록 기도하면서 데이터를 보내고 수신 장치에서 ACK응답을 보내길 기다렸습니다. 일정 시간이 지나도 ACK가 오지 않는다면 실패로 처리하고 다시 보내고, 프레임이 단 1비트라도 충돌한다면 전체를 그냥 버렸습니다. 이걸 성공하거나 지정된 최대 전송 횟수가 될 때까지 계속 반복했습니다. 당연히 효율은 약 18.4% 정도로 좋지 못했죠.\n이런 문제를 해결하기 위해 slot이라는 개념이 도입되었습니다, slot은 시간을 여러 칸으로 나눠서 slot이 시작되는 시점에만 데이터를 전송하는 겁니다. slot이 도입됨으로써 두 장치에서 보낸 데이터가 머리와 꼬리에서 충돌하는 일을 막을 수 있습니다. 그러니까, 고작 몇 비트 충돌로 전체를 다시 전송해야 하는 일은 없어진 것이죠. 효율은 약 36.8%로 올랐습니다.\n순수 ALOHA\nSlot이 적용된 ALOHA\n현대의 네트워크는 Slotted ALOHA보다 발전해서 다양한 규칙이 추가되었습니다. 시간 단위로 쪼개 쓰기, 주파수 대역대를 나누어 쓰기, 주파수를 코드로 쪼개서 쓰기 등등\nRust의 소유권 프로그래밍 언어에서 규칙을 두고 자원을 나누는 예로 Rust의 소유권과 라이프타임 개념을 들 수 있습니다. Rust에서 어떤 변수는 하나의 작업 흐름만 수정할 수 있습니다. 소유권을 옮기거나 복사하지 않는다면 변수 수정이 불가능합니다. 소유권에 대한 규칙은 무척 복잡하므로 이 글에서 전부 다루기 어렵습니다. 간단하게만 살펴보겠습니다.\nfn take_mut(d: \u0026mut i32) { *d += 1; } fn just_read(d: \u0026i32) { println!(d); } fn main() { let mut x = 1; let mrx = \u0026mut x; // x의 소유권을 가져옵니다. // x의 소유권이 이동했으므로, 이 지점에서 x는 사용할 수 없습니다. // just_read(\u0026x); // 소유권은 mrx에 있으므로 불가능합니다. take_mut(mrx); // take_mut 안으로 소유권이 옮겨졌다가 돌아옵니다. take_mut(mrx); // take_mut 안으로 소유권이 옮겨졌다가 돌아옵니다. // mrx가 더 이상 쓰이지 않으니 mrx의 소유권은 끝났습니다. // 여기서부터는 정상적으로 x를 쓸 수 있습니다. println!(\"{}\", x); } 관리를 위임하기 관리를 위임하는 방법은 자원을 사용할 수 있는 권한을 관리하는 구성요소를 하나 정해두고 이 구성요소가 모든 자원의 사용을 통제하는 것입니다. 규칙을 두고 나누는 방식과 다르게, 분배 역할만 전담하는 요소가 추가되어 추가적인 비용이 들어가지만 좀 더 유연하게 대응할 수 있다는 장점이 있습니다. 운영체제가 정확하게 이 역할을 수행합니다.\n운영체제 운영체제는 프로세스/쓰레드가 사용할 수 있는 모든 자원을 관리합니다. 스케줄러를 통해 프로세스/쓰레드의 컴퓨팅 자원 사용을 통제하고, 시스템 콜을 통하지 않으면 프로세스/스케줄러는 파일 읽기/쓰기, 소켓 열기/쓰기/읽기/닫기 전부 불가능합니다. 자원 별로 구체적으로 어떻게 관리하는지는 조금씩 다르지만(CPU 자원은 스케줄링, 메모리는 가상 메모리 시스템 등) 시스템 콜을 경유한다는 점은 동일합니다.\n합의하기 합의하기는 자원을 쓰고 싶은 모든 작업자들이 적당한 방식으로 누가 쓸지 합의하는 방식입니다. 관리를 위임하는 방법은 관리자가 단일 장애점이 되어 관리자가 정상 작동하지 않는다면 시스템 전체가 정상 작동할 수 없습니다. 합의하는 방식은 작업자 하나가 고장나도 시스템 전체에는 지장이 없다는 장점이 있습니다. 그 대신에, 합의하는 데에는 대체로 상당한 시간이 소모됩니다. 그래서 순수하게 합의만 이용하는 것이 아니라, 합의해서 관리자나 규칙을 정하는 방법으로 동작하게 됩니다.\nRaft 분산 합의 알고리즘 Raft 알고리즘은 분산 시스템에서 리더를 선출하는 알고리즘입니다. 즉, 모든 작업을 합의하는 것은 아니고 관리를 위임할 노드를 하나 뽑는 알고리즘입니다. 이렇게 한 이유는 당연히 매 작업마다 합의하게 되면 자원 소모가 상당하기 때문입니다.\nRaft 알고리즘에서는 다음 세 가지 역할이 정해져 있습니다. 첫째는 Leader로 모든 작업 명령을 전파하고 모든 노드가 동일하게 작업을 수행하게 만듭니다. 주기적으로 자신의 상태를 다른 Follower에게 전파합니다. 둘째는 Follower로 리더로부터 받은 명령을 처리합니다. 마지막은 Candidate로 리더가 어떤 이유로든 부재할 경우, Follower가 새 리더를 정하기 위해 전환된 것입니다.\n기본적으로 Leader는 모든 작업 명령을 가지고 모든 팔로워가 동일한 명령을 수행하도록 합니다. Follwer 과반이 정상적으로 작업을 수행했다면, 수행이 완료되지 않은 나머지 Follower도 정상 수행하도록 강제합니다. 중간에 Follwer가 고장났더라도 Leader가 가진 작업 명령을 그대로 복제해 수행하게 됩니다.\nRaft 알고리즘 구성\n맺음말 지금까지 소프트웨어가 여러 작업 흐름을 통제하는 방법을 알아보았습니다. 들어가는 글에서 언급했듯이 이 글은 개념적으로 어떤 방법을 쓰는지에 초점을 두었습니다. 더 자세한 정보를 원하신다면 따로 검색하시거나 아래 참조글을 확인하시면 되겠습니다.\n참조 Data communication \u0026 Networking, Behrouz A. Forouzan https://kjhoon0330.tistory.com/entry/운영체제OS-CPU-스케줄링 모두의 코드 https://modoocode.com/338 https://seongjin.me/raft-consensus-algorithm/ ","wordCount":"709","inLanguage":"en","datePublished":"2023-12-10T23:43:57+09:00","dateModified":"2023-12-10T23:43:57+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://maintain0404.github.io/posts/resource_managing_in_software.ko/"},"publisher":{"@type":"Organization","name":"Taein.dev","logo":{"@type":"ImageObject","url":"https://maintain0404.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://maintain0404.github.io/ accesskey=h title="Taein.dev (Alt + H)"><img src=https://maintain0404.github.io/apple-touch-icon.png alt aria-label=logo height=35>Taein.dev</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://maintain0404.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://maintain0404.github.io/archives title=archives><span>archives</span></a></li><li><a href=https://maintain0404.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://maintain0404.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://maintain0404.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법</h1><div class=post-meta><span title='2023-12-10 23:43:57 +0900 KST'>December 10, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;709 words&nbsp;·&nbsp;Me</div></header><div class=post-content><h1 id=글>글<a hidden class=anchor aria-hidden=true href=#글>#</a></h1><h2 id=들어가며>들어가며<a hidden class=anchor aria-hidden=true href=#들어가며>#</a></h2><p>프로그래밍에서 작업 흐름이 여럿인 경우를 제법 만날 수 있습니다. 목적부터 작업 흐름이 여럿일 수 있고(여러 사용자가 있는 구조), 더 빠른 처리를 위해 여럿을 사용할 수도 있고(병렬 프로그래밍), 관리를 위해 개념적으로 쪼개어 작업할 수 도 있습니다.</p><p>하지만 여러 작업 흐름을 고려하고 프로그래밍을 하면 작업 흐름끼리 충돌해서 프로그램이 죽어버리거나, 데이터가 오염되는 문제가 생길 수가 있습니다. 데이터베이스에서 간헐적으로 발생하는 데드락이나, 구글 독스 등 클라우드 프로그램을 이용할 때 글자가 갑자기 사라지는 것이 그 예시입니다.</p><p>이 글에서는 소프트웨어에서 여러 작업 흐름을 어떻게 제어하는지 개념적으로 간단히 알아보겠습니다.</p><h2 id=하나로-전부-처리하기>하나로 전부 처리하기<a hidden class=anchor aria-hidden=true href=#하나로-전부-처리하기>#</a></h2><p>튜닝의 끝은 수정이라는 말처럼 프로그래밍 관점에서 놀랍고 높은 수준이고 멋있는 기술을 사용하는 것은 아니지만 제일 좋은 방법입니다. 일단 생각할 게 없기 때문에 구현이 아주 쉽습니다. 그리고 누가 작업할지 따질 필요도 없기 때문에 아주 효율적입니다.</p><h2 id=규칙을-두고-나누기>규칙을 두고 나누기<a hidden class=anchor aria-hidden=true href=#규칙을-두고-나누기>#</a></h2><p>작업자 전부의 Ground Rule을 정하고 나누는 방법입니다. 규칙만 잘 정한다면 신경써야할 부분이 적고, 성능 손실도 적게 병렬 처리가 가능합니다.</p><h3 id=네트워크>네트워크<a hidden class=anchor aria-hidden=true href=#네트워크>#</a></h3><p>초창기 전송 프로토콜인 ALOHA에서는 충돌이 일어나지 않도록 기도하면서 데이터를 보내고 수신 장치에서 ACK응답을 보내길 기다렸습니다. 일정 시간이 지나도 ACK가 오지 않는다면 실패로 처리하고 다시 보내고, 프레임이 단 1비트라도 충돌한다면 전체를 그냥 버렸습니다. 이걸 성공하거나 지정된 최대 전송 횟수가 될 때까지 계속 반복했습니다. 당연히 효율은 약 18.4% 정도로 좋지 못했죠.</p><p>이런 문제를 해결하기 위해 slot이라는 개념이 도입되었습니다, slot은 시간을 여러 칸으로 나눠서 slot이 시작되는 시점에만 데이터를 전송하는 겁니다. slot이 도입됨으로써 두 장치에서 보낸 데이터가 머리와 꼬리에서 충돌하는 일을 막을 수 있습니다. 그러니까, 고작 몇 비트 충돌로 전체를 다시 전송해야 하는 일은 없어진 것이죠. 효율은 약 36.8%로 올랐습니다.</p><figure><img loading=lazy src=/static/images/pure-aloha.png#center alt="순수 ALOHA" width=40%></figure><p>순수 ALOHA</p><figure><img loading=lazy src=/static/images/slotted-aloha.png#center alt="Slotted ALOHA" width=40%></figure><p>Slot이 적용된 ALOHA</p><p>현대의 네트워크는 Slotted ALOHA보다 발전해서 다양한 규칙이 추가되었습니다. 시간 단위로 쪼개 쓰기, 주파수 대역대를 나누어 쓰기, 주파수를 코드로 쪼개서 쓰기 등등</p><h3 id=rust의-소유권>Rust의 소유권<a hidden class=anchor aria-hidden=true href=#rust의-소유권>#</a></h3><p>프로그래밍 언어에서 규칙을 두고 자원을 나누는 예로 Rust의 소유권과 라이프타임 개념을 들 수 있습니다. Rust에서 어떤 변수는 하나의 작업 흐름만 수정할 수 있습니다. 소유권을 옮기거나 복사하지 않는다면 변수 수정이 불가능합니다. 소유권에 대한 규칙은 무척 복잡하므로 이 글에서 전부 다루기 어렵습니다. 간단하게만 살펴보겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>take_mut</span><span class=p>(</span><span class=n>d</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=o>*</span><span class=n>d</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>just_read</span><span class=p>(</span><span class=n>d</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=fm>println!</span><span class=p>(</span><span class=n>d</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=n>mrx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>  </span><span class=c1>// x의 소유권을 가져옵니다.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>										 </span><span class=c1>// x의 소유권이 이동했으므로, 이 지점에서 x는 사용할 수 없습니다.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// just_read(&amp;x);  // 소유권은 mrx에 있으므로 불가능합니다.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>	</span><span class=n>take_mut</span><span class=p>(</span><span class=n>mrx</span><span class=p>);</span><span class=w>  </span><span class=c1>// take_mut 안으로 소유권이 옮겨졌다가 돌아옵니다.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>	</span><span class=n>take_mut</span><span class=p>(</span><span class=n>mrx</span><span class=p>);</span><span class=w>  </span><span class=c1>// take_mut 안으로 소유권이 옮겨졌다가 돌아옵니다.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>									</span><span class=c1>// mrx가 더 이상 쓰이지 않으니 mrx의 소유권은 끝났습니다.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>	</span><span class=c1>// 여기서부터는 정상적으로 x를 쓸 수 있습니다.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=관리를-위임하기>관리를 위임하기<a hidden class=anchor aria-hidden=true href=#관리를-위임하기>#</a></h2><p>관리를 위임하는 방법은 자원을 사용할 수 있는 권한을 관리하는 구성요소를 하나 정해두고 이 구성요소가 모든 자원의 사용을 통제하는 것입니다. 규칙을 두고 나누는 방식과 다르게, 분배 역할만 전담하는 요소가 추가되어 추가적인 비용이 들어가지만 좀 더 유연하게 대응할 수 있다는 장점이 있습니다. 운영체제가 정확하게 이 역할을 수행합니다.</p><h3 id=운영체제>운영체제<a hidden class=anchor aria-hidden=true href=#운영체제>#</a></h3><p>운영체제는 프로세스/쓰레드가 사용할 수 있는 모든 자원을 관리합니다. 스케줄러를 통해 프로세스/쓰레드의 컴퓨팅 자원 사용을 통제하고, 시스템 콜을 통하지 않으면 프로세스/스케줄러는 파일 읽기/쓰기, 소켓 열기/쓰기/읽기/닫기 전부 불가능합니다. 자원 별로 구체적으로 어떻게 관리하는지는 조금씩 다르지만(CPU 자원은 스케줄링, 메모리는 <a href=https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC>가상 메모리</a> 시스템 등) 시스템 콜을 경유한다는 점은 동일합니다.</p><h2 id=합의하기>합의하기<a hidden class=anchor aria-hidden=true href=#합의하기>#</a></h2><p>합의하기는 자원을 쓰고 싶은 모든 작업자들이 적당한 방식으로 누가 쓸지 합의하는 방식입니다. 관리를 위임하는 방법은 관리자가 단일 장애점이 되어 관리자가 정상 작동하지 않는다면 시스템 전체가 정상 작동할 수 없습니다. 합의하는 방식은 작업자 하나가 고장나도 시스템 전체에는 지장이 없다는 장점이 있습니다. 그 대신에, 합의하는 데에는 대체로 상당한 시간이 소모됩니다. 그래서 순수하게 합의만 이용하는 것이 아니라, 합의해서 관리자나 규칙을 정하는 방법으로 동작하게 됩니다.</p><h3 id=raft-분산-합의-알고리즘>Raft 분산 합의 알고리즘<a hidden class=anchor aria-hidden=true href=#raft-분산-합의-알고리즘>#</a></h3><p>Raft 알고리즘은 분산 시스템에서 리더를 선출하는 알고리즘입니다. 즉, 모든 작업을 합의하는 것은 아니고 관리를 위임할 노드를 하나 뽑는 알고리즘입니다. 이렇게 한 이유는 당연히 매 작업마다 합의하게 되면 자원 소모가 상당하기 때문입니다.</p><p>Raft 알고리즘에서는 다음 세 가지 역할이 정해져 있습니다. 첫째는 Leader로 모든 작업 명령을 전파하고 모든 노드가 동일하게 작업을 수행하게 만듭니다. 주기적으로 자신의 상태를 다른 Follower에게 전파합니다. 둘째는 Follower로 리더로부터 받은 명령을 처리합니다. 마지막은 Candidate로 리더가 어떤 이유로든 부재할 경우, Follower가 새 리더를 정하기 위해 전환된 것입니다.</p><p>기본적으로 Leader는 모든 작업 명령을 가지고 모든 팔로워가 동일한 명령을 수행하도록 합니다. Follwer 과반이 정상적으로 작업을 수행했다면, 수행이 완료되지 않은 나머지 Follower도 정상 수행하도록 강제합니다. 중간에 Follwer가 고장났더라도 Leader가 가진 작업 명령을 그대로 복제해 수행하게 됩니다.</p><figure><img loading=lazy src=/static/images/raft-structure.png#center alt="Raft 알고리즘" width=40%></figure><p>Raft 알고리즘 구성</p><h2 id=맺음말>맺음말<a hidden class=anchor aria-hidden=true href=#맺음말>#</a></h2><p>지금까지 소프트웨어가 여러 작업 흐름을 통제하는 방법을 알아보았습니다. 들어가는 글에서 언급했듯이 이 글은 개념적으로 어떤 방법을 쓰는지에 초점을 두었습니다. 더 자세한 정보를 원하신다면 따로 검색하시거나 아래 참조글을 확인하시면 되겠습니다.</p><h2 id=참조>참조<a hidden class=anchor aria-hidden=true href=#참조>#</a></h2><ol><li>Data communication & Networking, Behrouz A. Forouzan</li><li><a href=https://kjhoon0330.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81>https://kjhoon0330.tistory.com/entry/운영체제OS-CPU-스케줄링</a></li><li>모두의 코드<ol><li><a href=https://modoocode.com/338>https://modoocode.com/338</a></li></ol></li><li><a href=https://seongjin.me/raft-consensus-algorithm/>https://seongjin.me/raft-consensus-algorithm/</a></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://maintain0404.github.io/posts/asgi_deep_dive.ko/><span class=title>« Prev</span><br><span>ASGI 깊게 살펴보기</span>
</a><a class=next href=https://maintain0404.github.io/posts/first_product_release_review.ko/><span class=title>Next »</span><br><span>처음으로 프로덕트를 공개해본 후기</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법 on x" href="https://x.com/intent/tweet/?text=%ec%86%8c%ed%8a%b8%ed%8a%b8%ec%9b%a8%ec%96%b4%ec%97%90%ec%84%9c%20%ec%97%ac%eb%9f%ac%20%ec%9e%91%ec%97%85%20%ed%9d%90%eb%a6%84%ec%9d%84%20%ea%b4%80%eb%a6%ac%ed%95%98%eb%8a%94%20%eb%8b%a4%ec%96%91%ed%95%9c%20%eb%b0%a9%eb%b2%95&amp;url=https%3a%2f%2fmaintain0404.github.io%2fposts%2fresource_managing_in_software.ko%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmaintain0404.github.io%2fposts%2fresource_managing_in_software.ko%2f&amp;title=%ec%86%8c%ed%8a%b8%ed%8a%b8%ec%9b%a8%ec%96%b4%ec%97%90%ec%84%9c%20%ec%97%ac%eb%9f%ac%20%ec%9e%91%ec%97%85%20%ed%9d%90%eb%a6%84%ec%9d%84%20%ea%b4%80%eb%a6%ac%ed%95%98%eb%8a%94%20%eb%8b%a4%ec%96%91%ed%95%9c%20%eb%b0%a9%eb%b2%95&amp;summary=%ec%86%8c%ed%8a%b8%ed%8a%b8%ec%9b%a8%ec%96%b4%ec%97%90%ec%84%9c%20%ec%97%ac%eb%9f%ac%20%ec%9e%91%ec%97%85%20%ed%9d%90%eb%a6%84%ec%9d%84%20%ea%b4%80%eb%a6%ac%ed%95%98%eb%8a%94%20%eb%8b%a4%ec%96%91%ed%95%9c%20%eb%b0%a9%eb%b2%95&amp;source=https%3a%2f%2fmaintain0404.github.io%2fposts%2fresource_managing_in_software.ko%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmaintain0404.github.io%2fposts%2fresource_managing_in_software.ko%2f&title=%ec%86%8c%ed%8a%b8%ed%8a%b8%ec%9b%a8%ec%96%b4%ec%97%90%ec%84%9c%20%ec%97%ac%eb%9f%ac%20%ec%9e%91%ec%97%85%20%ed%9d%90%eb%a6%84%ec%9d%84%20%ea%b4%80%eb%a6%ac%ed%95%98%eb%8a%94%20%eb%8b%a4%ec%96%91%ed%95%9c%20%eb%b0%a9%eb%b2%95"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmaintain0404.github.io%2fposts%2fresource_managing_in_software.ko%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법 on whatsapp" href="https://api.whatsapp.com/send?text=%ec%86%8c%ed%8a%b8%ed%8a%b8%ec%9b%a8%ec%96%b4%ec%97%90%ec%84%9c%20%ec%97%ac%eb%9f%ac%20%ec%9e%91%ec%97%85%20%ed%9d%90%eb%a6%84%ec%9d%84%20%ea%b4%80%eb%a6%ac%ed%95%98%eb%8a%94%20%eb%8b%a4%ec%96%91%ed%95%9c%20%eb%b0%a9%eb%b2%95%20-%20https%3a%2f%2fmaintain0404.github.io%2fposts%2fresource_managing_in_software.ko%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법 on telegram" href="https://telegram.me/share/url?text=%ec%86%8c%ed%8a%b8%ed%8a%b8%ec%9b%a8%ec%96%b4%ec%97%90%ec%84%9c%20%ec%97%ac%eb%9f%ac%20%ec%9e%91%ec%97%85%20%ed%9d%90%eb%a6%84%ec%9d%84%20%ea%b4%80%eb%a6%ac%ed%95%98%eb%8a%94%20%eb%8b%a4%ec%96%91%ed%95%9c%20%eb%b0%a9%eb%b2%95&amp;url=https%3a%2f%2fmaintain0404.github.io%2fposts%2fresource_managing_in_software.ko%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 소트트웨어에서 여러 작업 흐름을 관리하는 다양한 방법 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ec%86%8c%ed%8a%b8%ed%8a%b8%ec%9b%a8%ec%96%b4%ec%97%90%ec%84%9c%20%ec%97%ac%eb%9f%ac%20%ec%9e%91%ec%97%85%20%ed%9d%90%eb%a6%84%ec%9d%84%20%ea%b4%80%eb%a6%ac%ed%95%98%eb%8a%94%20%eb%8b%a4%ec%96%91%ed%95%9c%20%eb%b0%a9%eb%b2%95&u=https%3a%2f%2fmaintain0404.github.io%2fposts%2fresource_managing_in_software.ko%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=maintain0404/blog issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://maintain0404.github.io/>Taein.dev</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>